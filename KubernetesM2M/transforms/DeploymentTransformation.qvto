import PrimativeDataTypesHelper;

library DeploymentTransformation;


modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype KuberntesMetaModel uses 'http://www.example.org/kubernetesModel';
modeltype kuberProfile uses 'http://kubernetesProfile';

/**
* Return a deployment that has standard attributes for mysql.
**/

helper UML::Node::mysqlToDeployment(inout deployment : KuberntesMetaModel::Deployment, in mysqlStereoType :UML::Stereotype,inout infra : KuberntesMetaModel::Infrastructure )  {
		deployment.name := self.name;
		deployment.port := 3306;
		deployment.replicas := 1;	
		deployment.image := "mysql:"+self.getString(mysqlStereoType,"version");
		var rootPassword := self.getValue(mysqlStereoType,"rootPassword").oclAsType(kuberProfile::DataTypes::RootPassword);
		var dataBaseName := self.getValue(mysqlStereoType,"dataBase").oclAsType(kuberProfile::DataTypes::MySqlDatabase);
		var mySqlDumpFile := self.getValue(mysqlStereoType,"mysqlDumpFile").oclAsType(kuberProfile::DataTypes::MySQLDumpfile);
		
		
		var pvc := new PersistentVolumeClaim();
		var pvcName :=self.name + "-pvc";
		pvc.size := self.getInteger(mysqlStereoType,"storageSizeInGB");	
		pvc.name := pvcName;
	 		
		var volume := new Volume();
		var volumeName := self.name + "-persistent-storage";
		volume.name := volumeName;
		volume.type := KuberntesMetaModel::VolumeType::persistentVolumeClaim;
		volume.claimName := pvcName;
	 		
		var volumeMount := new VolumeMount();
		volumeMount.name := volumeName;
		volumeMount.mountPath := "/var/lib/mysql";	 		
		deployment.volumes += volume;
		deployment.volumeMounts += volumeMount;
	 		
	 	
	 	if(rootPassword <> null){
	 		var pw := new EnviromentVariables();
	 		pw.name := "MYSQL_ROOT_PASSWORD";
	 		pw.value := rootPassword.passsword;
	 		deployment.enviromentVariables += pw;
	 	};	
	 	if(dataBaseName <> null){
	 		var db := new EnviromentVariables();
	 		db.name := "MYSQL_DATABASE";
	 		db.value := dataBaseName.name;
	 		deployment.enviromentVariables += db;
	 	};	
	 	if(mySqlDumpFile <> null){
	 		log("anders");
	 		var configMap := new ConfigMap();
	 		var configMapName := self.name + "-sql-dump";
	 		configMap.name := configMapName;
	 		configMap.isDump := true;
	 		configMap.fileName := mySqlDumpFile.filePath;
	 		
	 		
	 		infra.objectsCount := infra.objectsCount +1;
	 		configMap.id := infra.objectsCount;
	 		infra.configMaps += configMap;
	 		
	 		var cVolume := new Volume();
	 		var cVolumeName := "usermanagement-dbcreation-script";
	 		cVolume.name :="usermanagement-dbcreation-script";
	 		cVolume.type := KuberntesMetaModel::VolumeType::configMap;
	 		cVolume.configMapName := configMapName;
	 		
	 		var cVolumeMount := new VolumeMount();
	 		cVolumeMount.mountPath := "/docker-entrypoint-initdb.d";
	 		cVolumeMount.name := cVolumeName;
	 		deployment.volumeMounts += cVolumeMount;
	 		deployment.volumes += cVolume;
	 		
	 	};
		infra.objectsCount := infra.objectsCount +1;
		pvc.id := infra.objectsCount;
		infra.persistentVolumeClaims += pvc;	
		
		

		
}
helper UML::Node::mongoToDeployment(inout deployment : KuberntesMetaModel::Deployment, in mongoStereotype :UML::Stereotype )  {
	deployment.name := self.name;
	deployment.port := 27017;
	deployment.replicas := 1;
	deployment.image := "mongo";
	var rootPassword := self.getValue(mongoStereotype,"rootPassword").oclAsType(kuberProfile::DataTypes::RootPassword);

		
	var pvc := new PersistentVolumeClaim();
	var pvcName :=self.name + "-pvc";
	pvc.size := self.getInteger(mongoStereotype,"storageSizeInGB");	
	pvc.name := pvcName;
	 		
	var volume := new Volume();
	var volumeName := self.name + "-persistent-storage";
	volume.name := volumeName;
	volume.type := KuberntesMetaModel::VolumeType::persistentVolumeClaim;
	volume.claimName := pvcName;
	 		
	var volumeMount := new VolumeMount();
	volumeMount.name := volumeName;
	volumeMount.mountPath := "/data/db";	 		
	deployment.volumes += volume;
	deployment.volumeMounts += volumeMount;
	 		
	 	
	 if(rootPassword <> null){
	 	var pw := new EnviromentVariables();
	 	var root := new EnviromentVariables();
	 	root.name := "MONGO_INITDB_ROOT_USERNAME";
	 	root.value := "root";
	 	pw.name := "MONGO_INITDB_ROOT_PASSWORD";
	 	pw.value := rootPassword.passsword;
	 	deployment.enviromentVariables += pw;
	 };	

	
}


helper UML::Node::deploymentToDeployment(inout deployment: KuberntesMetaModel::Deployment, in deploymentStereoType : UML::Stereotype, inout infra : KuberntesMetaModel::Infrastructure ){
	    deployment.image := self.getString(deploymentStereoType,"image");
	    deployment.port := self.getInteger(deploymentStereoType,"port");
	    deployment.replicas := self.getInteger(deploymentStereoType,"replicas");
	    deployment.name := self.name;
	    deployment.dataPersistent := self.getDataPersistent(deploymentStereoType);
	    deployment.enviromentVariables += self.getEnviromentVariables(deploymentStereoType);	  	  	
	  
	 	var dataPersistent :=	self.getValue(deploymentStereoType,"dataPersistent").oclAsType(kuberProfile::DataTypes::PersistentData);
	 	
	 	if(dataPersistent <> null){
	 		log("asd");
	 		var pvc := new PersistentVolumeClaim();
	 		var pvcName :=self.name + "-pvc";
	 		pvc.size := dataPersistent.sizeInGB;
	 		pvc.name := pvcName;
	 		
	 		var volume := new Volume();
	 		var volumeName := self.name + "-persistent-storage";
	 		volume.name := volumeName;
	 		volume.type := KuberntesMetaModel::VolumeType::persistentVolumeClaim;
	 		volume.claimName := pvcName;
	 		
	 		var volumeMount := new VolumeMount();
	 		volumeMount.name := volumeName;
	 		volumeMount.mountPath := dataPersistent.mountPath;
	 		
	 		deployment.volumes += volume;
	 		deployment.volumeMounts += volumeMount;
	 		
	 		
	 		infra.objectsCount := infra.objectsCount +1;
			pvc.id := infra.objectsCount;
	 		infra.persistentVolumeClaims += pvc;		
	 	
	 		
	 	};
	  	if(deploymentStereoType.name = "AdvancedDeployment"){	  	
	  		deployment.securityContext := self.getSecurityContext(deploymentStereoType);
	  		deployment.resourceAllocation := self.getResourceAllocation(deploymentStereoType);
	  		deployment.args := self.getArguments(deploymentStereoType);
	  		deployment.command := self.getCommand(deploymentStereoType);
	  		deployment.memoryMount := self.getMemoryMount(deploymentStereoType);
	  		deployment.additionalPorts := self.getAdditionalPorts(deploymentStereoType);
	  	}; 	
	  
	    
	  
}

helper UML::Node::getAdditionalPorts(in deploymentStereoType: UML::Stereotype): OrderedSet(KuberntesMetaModel::Port){
	
	var ports: Set(KuberntesMetaModel::Port);
	self.getValue(deploymentStereoType,"additionalPorts")->flatten()->asSequence()->forEach(port){
		
	
		var p = new KuberntesMetaModel::Port();
		p.number := port.oclAsType(kuberProfile::DataTypes::Port).port;
		p.name := port.oclAsType(kuberProfile::DataTypes::Port).portName;
		ports += p;
	};
	if(ports->notEmpty()){
		return ports->asOrderedSet();
	};
	
	return null;
}
helper UML::Node::getMemoryMount(in deploymentStereoType : UML::Stereotype): String {
	var memoryMount := self.getValue(deploymentStereoType,"memoryMount").oclAsType(kuberProfile::DataTypes::MemoryMount);
	
	if(memoryMount <> null){
		

		return memoryMount.mountPath;
	};
	return null;
}
helper UML::Node::getCommand(in deploymentStereoType : UML::Stereotype): String{
	var command := self.getValue(deploymentStereoType,"command");
	
	if(command <> null){
		return command.oclAsType(String);
	};
	return null;
}

helper UML::Node::getArguments(in deploymentStereoType : UML::Stereotype): OrderedSet(String){

	var returnArgs: Set(String);
	self.getValue(deploymentStereoType,"args")->flatten()->asSequence()->forEach(variable){
			log(variable.toString());
			returnArgs += variable.oclAsType(String);
	};
	if(returnArgs->notEmpty()){
		return returnArgs->asOrderedSet();
	};
	
	return null;
}

helper UML::Node::getSecurityContext(in deploymentStereoType : UML::Stereotype): SecurityContext{
	var securityContext := self.getValue(deploymentStereoType,"securityContext").oclAsType(kuberProfile::DataTypes::SecurityContext);
	
	if(securityContext <> null){
		var returnSecurityContext = new SecurityContext();
	
	
		returnSecurityContext.runAsUser := securityContext.runAsUser;
		returnSecurityContext.runAsRoot := securityContext.runAsRoot;
		returnSecurityContext.runAsGroup := securityContext.runAsGroup;
		returnSecurityContext.fsGroup := securityContext.fsGroup;
		returnSecurityContext.readOnlyRootFilesystem := securityContext.readOnlyRootFilesystem;
	
		returnSecurityContext.capabilities := securityContext.getCapabilities();
		return returnSecurityContext;
	};
	return null;

}
helper kuberProfile::DataTypes::SecurityContext::getCapabilities() : Capabilities{
	
	
	var cap = new Capabilities();
	self->capabilities.add->forEach(add) {	
		cap.add += add;
	};
	self->capabilities.drop->forEach(drop) {	
		cap.drop += drop;
	};
	return cap;
}

helper UML::Node::getResourceAllocation(in deploymentStereoType : UML::Stereotype) : ResourceAllocation {
	var resourceSpecification := self.getValue(deploymentStereoType, "resourceSpecification").oclAsType(kuberProfile::DataTypes::ResourceSpecification);
	var limit := resourceSpecification.limit;
	var request := resourceSpecification.request;
	



	if(limit.cpuUtalization > 0 and limit.memory > 0 and request.cpuUtalization > 0 and request.memory > 0){
		
		var returnResourceAlloc := new ResourceAllocation();
 		returnResourceAlloc.cpuLimit :=(limit.cpuUtalization * 1000).floor().toString() + "m";
		returnResourceAlloc.cpuRequest :=(request.cpuUtalization * 1000).floor().toString() + "m";
	
		returnResourceAlloc.memoryLimit := limit.memory.toString() + "Mi";
		returnResourceAlloc.memoryRequest := request.memory.toString() + "Mi";
		return returnResourceAlloc;
	};


	return null;
}
helper UML::Node::getEnviromentVariables(in deploymentStereoType : UML::Stereotype) : OrderedSet(EnviromentVariables){

	var environmentVariables :=	self.getValue(deploymentStereoType,"environmentVariables"); //.oclAsType(KuberProfile2::EnviromentVariables);
	var nodeEnviromentVars: Set(EnviromentVariables);
	
	
	environmentVariables->flatten()->asSequence()->forEach(variable){	
	 //log("found environment variable ToString is:" + variable.toString() + " and repr is: " + variable.repr());
	    var name := variable.oclAsType(kuberProfile::DataTypes::EnviromentVariables).name;
	    var value := variable.oclAsType(kuberProfile::DataTypes::EnviromentVariables).value;
	    //log("found environment variable: name-value are:" + name.toString()+"-"+value.toString());
	    var newEnv = new EnviromentVariables();		  
	  	
		newEnv.name := name;
	    newEnv.value := value;
				
		nodeEnviromentVars +=newEnv;              
	};	
	return nodeEnviromentVars->asOrderedSet();
}


helper UML::Node::getDataPersistent(in deploymentStereoType : UML::Stereotype) : PersistentData {
	
	var dataPersistent :=	self.getValue(deploymentStereoType,"dataPersistent");
	if(dataPersistent <> null){
		var size := dataPersistent.oclAsType(kuberProfile::DataTypes::PersistentData).sizeInGB;
		var mountPath := dataPersistent.oclAsType(kuberProfile::DataTypes::PersistentData).mountPath;
		var pd := new PersistentData();
		pd.mountPath := mountPath;
		pd.sizeInGB := size;
		return pd;
	
	};	
	return null;
}

