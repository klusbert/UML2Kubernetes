import PrimativeDataTypesHelper;

library DeploymentTransformation;

modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype KuberntesMetaModel uses 'http://www.example.org/kubernetesModel';
modeltype kuberProfile uses 'http://kubernetesProfile';

/**
* Return a deployment that has standard attributes for mysql.
**/

helper UML::Node::mysqlToDeployment(inout deployment : KuberntesMetaModel::Deployment, in mysqlStereoType :UML::Stereotype )  {
		deployment.port := 3306;
		deployment.replicas := 1;	
		deployment.image := "mysql:"+self.getString(mysqlStereoType,"version");
		var pvc := new PersistentData();
		pvc.mountPath := "/var/lib/mysql";
		pvc.sizeInGB := self.getInteger(mysqlStereoType,"storageSizeInGB");		
		deployment.dataPersistent := pvc;
		
		var databaseNameEnv := new EnviromentVariables();
		var rootPassword := new EnviromentVariables();
		
		databaseNameEnv.name :="MYSQL_DATABASE";
		databaseNameEnv.value := self.getString(mysqlStereoType, "databaseName");		
		
		rootPassword.name :="MYSQL_ROOT_PASSWORD";
		rootPassword.value := self.getString(mysqlStereoType, "rootPassword");		
		
		
		deployment.enviromentVariables += databaseNameEnv;
		deployment.enviromentVariables += rootPassword;
		
}
helper UML::Node::mongoToDeployment(inout deployment : KuberntesMetaModel::Deployment, in mongoStereotype :UML::Stereotype )  {
	deployment.port := 27017;
	deployment.replicas := 1;
	deployment.image := "mongo";
	var pvc := new PersistentData();
	pvc.mountPath := "/data/db";
	pvc.sizeInGB := self.getInteger(mongoStereotype,"storageSizeInGB");		
	deployment.dataPersistent := pvc;
	
	var rootUser := new EnviromentVariables();
	rootUser.name :="MONGO_INITDB_ROOT_USERNAME";
	rootUser.value := "root";	
	
	
	var rootPassword := new EnviromentVariables();
	rootPassword.name :="MONGO_INITDB_ROOT_PASSWORD";
	rootPassword.value := self.getString(mongoStereotype, "rootPassword");		
	
	deployment.enviromentVariables += rootUser;
	deployment.enviromentVariables += rootPassword;
}


helper UML::Node::deploymentToDeployment(inout deployment: KuberntesMetaModel::Deployment, in deploymentStereoType : UML::Stereotype, in namespace : String){
	    deployment.image := self.getString(deploymentStereoType,"image");
	    deployment.port := self.getInteger(deploymentStereoType,"port");
	    deployment.replicas := self.getInteger(deploymentStereoType,"replicas");
	    
	    deployment.dataPersistent := self.getDataPersistent(deploymentStereoType);
	    deployment.enviromentVariables += self.getEnviromentVariables(deploymentStereoType, namespace);	  	  	
	  
	  	if(deploymentStereoType.name = "AdvancedDeployment"){	  	
	  		deployment.securityContext := self.getSecurityContext(deploymentStereoType);
	  		deployment.resourceAllocation := self.getResourceAllocation(deploymentStereoType);
	  		deployment.args := self.getArguments(deploymentStereoType);
	  		deployment.command := self.getCommand(deploymentStereoType);
	  		deployment.memoryMount := self.getMemoryMount(deploymentStereoType);
	  		deployment.additionalPorts := self.getAdditionalPorts(deploymentStereoType);
	  	}; 	
	  
	    
	  
}

helper UML::Node::getAdditionalPorts(in deploymentStereoType: UML::Stereotype): OrderedSet(KuberntesMetaModel::Port){
	
	var ports: Set(KuberntesMetaModel::Port);
	self.getValue(deploymentStereoType,"additionalPorts")->flatten()->asSequence()->forEach(port){
		
	
		var p = new KuberntesMetaModel::Port();
		p.number := port.oclAsType(kuberProfile::DataTypes::Port).port;
		p.name := port.oclAsType(kuberProfile::DataTypes::Port).portName;
		ports += p;
	};
	if(ports->notEmpty()){
		return ports->asOrderedSet();
	};
	
	return null;
}
helper UML::Node::getMemoryMount(in deploymentStereoType : UML::Stereotype): String {
	var memoryMount := self.getValue(deploymentStereoType,"memoryMount").oclAsType(kuberProfile::DataTypes::MemoryMount);
	
	if(memoryMount <> null){
		

		return memoryMount.mountPath;
	};
	return null;
}
helper UML::Node::getCommand(in deploymentStereoType : UML::Stereotype): String{
	var command := self.getValue(deploymentStereoType,"command");
	
	if(command <> null){
		return command.oclAsType(String);
	};
	return null;
}

helper UML::Node::getArguments(in deploymentStereoType : UML::Stereotype): OrderedSet(String){

	var returnArgs: Set(String);
	self.getValue(deploymentStereoType,"args")->flatten()->asSequence()->forEach(variable){
			log(variable.toString());
			returnArgs += variable.oclAsType(String);
	};
	if(returnArgs->notEmpty()){
		return returnArgs->asOrderedSet();
	};
	
	return null;
}

helper UML::Node::getSecurityContext(in deploymentStereoType : UML::Stereotype): SecurityContext{
	var securityContext := self.getValue(deploymentStereoType,"securityContext").oclAsType(kuberProfile::DataTypes::SecurityContext);
	
	if(securityContext <> null){
		var returnSecurityContext = new SecurityContext();
	
	
		returnSecurityContext.runAsUser := securityContext.runAsUser;
		returnSecurityContext.runAsRoot := securityContext.runAsRoot;
		returnSecurityContext.runAsGroup := securityContext.runAsGroup;
		returnSecurityContext.fsGroup := securityContext.fsGroup;
		returnSecurityContext.readOnlyRootFilesystem := securityContext.readOnlyRootFilesystem;
	
		returnSecurityContext.capabilities := securityContext.getCapabilities();
		return returnSecurityContext;
	};
	return null;

}
helper kuberProfile::DataTypes::SecurityContext::getCapabilities() : Capabilities{
	
	
	var cap = new Capabilities();
	self->capabilities.add->forEach(add) {	
		cap.add += add;
	};
	self->capabilities.drop->forEach(drop) {	
		cap.drop += drop;
	};
	return cap;
}

helper UML::Node::getResourceAllocation(in deploymentStereoType : UML::Stereotype) : ResourceAllocation {
	var resourceSpecification := self.getValue(deploymentStereoType, "resourceSpecification").oclAsType(kuberProfile::DataTypes::ResourceSpecification);
	var limit := resourceSpecification.limit;
	var request := resourceSpecification.request;
	



	if(limit.cpuUtalization > 0 and limit.memory > 0 and request.cpuUtalization > 0 and request.memory > 0){
		
		var returnResourceAlloc := new ResourceAllocation();
 		returnResourceAlloc.cpuLimit :=(limit.cpuUtalization * 1000).floor().toString() + "m";
		returnResourceAlloc.cpuRequest :=(request.cpuUtalization * 1000).floor().toString() + "m";
	
		returnResourceAlloc.memoryLimit := limit.memory.toString() + "Mi";
		returnResourceAlloc.memoryRequest := request.memory.toString() + "Mi";
		return returnResourceAlloc;
	};


	return null;
}
helper UML::Node::getEnviromentVariables(in deploymentStereoType : UML::Stereotype, in namespace :String) : OrderedSet(EnviromentVariables){

	var environmentVariables :=	self.getValue(deploymentStereoType,"environmentVariables"); //.oclAsType(KuberProfile2::EnviromentVariables);
	var nodeEnviromentVars: Set(EnviromentVariables);
	
	
	environmentVariables->flatten()->asSequence()->forEach(variable){		
	    var name := variable.oclAsType(kuberProfile::DataTypes::EnviromentVariables).name;
	    var value := variable.oclAsType(kuberProfile::DataTypes::EnviromentVariables).value;
	    var newEnv = new EnviromentVariables();	
	  
	    if(value.indexOf("$dns") > 0){	    
	
	       value := value.replace("$dns",namespace.toLower() +".svc.cluster.local");	    
		   log(value);
	    };
	
		newEnv.name := name;
	    newEnv.value := value;
				
		nodeEnviromentVars +=newEnv;              
	};	
	return nodeEnviromentVars->asOrderedSet();
}


helper UML::Node::getDataPersistent(in deploymentStereoType : UML::Stereotype) : PersistentData {
	
	var dataPersistent :=	self.getValue(deploymentStereoType,"dataPersistent");
	if(dataPersistent <> null){
		var size := dataPersistent.oclAsType(kuberProfile::DataTypes::PersistentData).sizeInGB;
		var mountPath := dataPersistent.oclAsType(kuberProfile::DataTypes::PersistentData).mountPath;
		var pd := new PersistentData();
		pd.mountPath := mountPath;
		pd.sizeInGB := size;
		return pd;
	
	};	
	return null;
}

